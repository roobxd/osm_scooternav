<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>iD</title>
    <link rel='stylesheet' href='iD.css'>
    <link rel='preconnect' href='https://fonts.googleapis.com'>
    <link rel='preconnect' href='https://fonts.gstatic.com' crossorigin>
    <link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap' rel='stylesheet'>
    <link rel='icon' type='image/png' href='data:image/png;base64,iVBORw0KGgo='>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no'/>
    <meta name='mobile-web-app-capable' content='yes'/>
    <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent'/>
    <style type='text/css'>
      /* apply document-level styling to standalone iD only */
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        /* disable elastic page bounce upon scroll */
        overflow: hidden;
      }
    </style>
    <!-- ScooterNav theme overrides -->
    <style>
      /* Global font improvements */
      :root { --app-font: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif; }
      html, body { font-family: var(--app-font); }
      /* Form controls */
      input, button, textarea, select { font-family: var(--app-font); }
      /* Enforce font across iD UI and map labels */
      #id-container, #id-container * { font-family: var(--app-font) !important; }
      #id-container svg text { font-family: var(--app-font) !important; }
      .badge { background:#E63A46 !important; color:#fff; }
      .btn:focus { outline: 2px solid #E63A46; outline-offset: 2px; box-shadow: 0 0 0 3px rgba(230,58,70,.25); }
      /* Map line color overrides: alleen onze dataset (.layer-mapdata) rood per wegtype */
      .layer-mapdata path.line.casing.tag-highway { stroke: #8B1E26 !important; }
      .layer-mapdata path.line.stroke.tag-highway { stroke: #E63A46 !important; }
      /* Per wegtype variaties (roodtinten) */
      .layer-mapdata path.line.stroke.tag-highway-motorway { stroke: #E63A46 !important; }
      .layer-mapdata path.line.stroke.tag-highway-trunk { stroke: #E25760 !important; }
      .layer-mapdata path.line.stroke.tag-highway-primary { stroke: #E86A74 !important; }
      .layer-mapdata path.line.stroke.tag-highway-secondary { stroke: #ED7D88 !important; }
      .layer-mapdata path.line.stroke.tag-highway-tertiary { stroke: #F2909C !important; }
      .layer-mapdata path.line.stroke.tag-highway-residential,
      .layer-mapdata path.line.stroke.tag-highway-service,
      .layer-mapdata path.line.stroke.tag-highway-unclassified,
      .layer-mapdata path.line.stroke.tag-highway-road { stroke: #F59BA6 !important; }
    </style>
    </style>
  </head>

  <body>
    <style>
      /* Hide iD’s built-in Save button to avoid OSM upload flow */
      .top-toolbar button.save { display: none !important; }

      .topbar { padding: 10px; background: linear-gradient(180deg,#f9fafb,#f1f5f9); border-bottom: 1px solid #e5e7eb; display:flex; gap:10px; align-items:center; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
      .btn { appearance:none; border:1px solid #d1d5db; background:#fff; color:#111827; padding:8px 12px; border-radius:8px; font-size:14px; line-height:1; cursor:pointer; transition: all .15s ease; }
      .btn:hover { box-shadow:0 1px 2px rgba(0,0,0,.06); transform: translateY(-1px); }
      .btn:disabled { opacity:.45; cursor:not-allowed; }
      /* ScooterNav red accents */
      .btn-primary { background:#E63A46; border-color:#E63A46; color:#fff; }
      .btn-primary:hover { background:#C5303B; }
      .btn-primary:disabled { background:#f79aa3; border-color:#f79aa3; color:#fff; }
      .badge { display:inline-block; min-width:16px; padding:2px 6px; margin-left:8px; border-radius:999px; background:#E63A46; color:#fff; font-weight:600; font-size:12px; }
      .status { margin-left:auto; color:#374151; font-size:13px; display:flex; align-items:center; gap:8px; }
      .status-dot { width:8px; height:8px; border-radius:999px; background:#ef4444; }
      .status-dot.online { background:#10b981; }
      /* Maxspeed visualization: color-code roads by speed so changes are visible */
      path.line.stroke.tag-maxspeed-30 { stroke: #4f46e5 !important; }
      path.line.stroke.tag-maxspeed-50 { stroke: #10b981 !important; }
      path.line.stroke.tag-maxspeed-60 { stroke: #22c55e !important; }
      path.line.stroke.tag-maxspeed-80 { stroke: #f59e0b !important; }
      path.line.stroke.tag-maxspeed-100 { stroke: #ef4444 !important; }
      path.line.stroke.tag-maxspeed-120 { stroke: #dc2626 !important; }
      /* Emphasize roads with a maxspeed tag */
      path.line.stroke[class*='tag-maxspeed-'] { stroke-width: 2.5px; }
      path.line.casing[class*='tag-maxspeed-'] { stroke-width: 4px; }
    </style>
    <div id='topbar' class='topbar'>
      <button id='btn-login' class='btn btn-primary'>Login</button>
      <button id='btn-logout' class='btn btn-primary'>Logout</button>
      <button id='btn-admin' class='btn' style='display:none;'>Admin</button>
      <button id='btn-load-local' class='btn'>Load Local Streets</button>
      <button id='btn-save' class='btn'>Save <span class='badge'>0</span></button>
      <div id='status' class='status'><span id='status-dot' class='status-dot'></span><span id='status-text'>Not logged in</span></div>
    </div>

    <!-- Toast container for lightweight notifications -->
    <div id='toast-container' style='position:fixed; top:8px; right:8px; display:flex; flex-direction:column; gap:6px; z-index:1000; pointer-events:none;'></div>
    <div id='id-container' style='position:absolute; top:40px; bottom:0; left:0; right:0; display:none;'></div>
    <div id='map-overlay' style='position:absolute; top:40px; bottom:0; left:0; right:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#f8fafc,#f1f5f9); border-top:1px solid #e5e7eb;'>
      <div style='text-align:center; max-width:360px; width:100%; padding:16px;'>
        <div id='overlay-title' style='font-size:18px; font-weight:600; color:#111827; margin-bottom:8px;'>Login required to view the map</div>
        <div id='overlay-desc' style='font-size:13px; color:#374151; margin-bottom:16px;'>Not logged in</div>
        <div class='login-form' style='display:flex; flex-direction:column; gap:10px; text-align:left;'>
          <label for='login-username' id='label-username' style='font-size:13px; color:#374151;'>Username</label>
          <input id='login-username' type='text' class='login-input' style='padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:14px;' autocomplete='username'>
          <label for='login-password' id='label-password' style='font-size:13px; color:#374151;'>Password</label>
          <input id='login-password' type='password' class='login-input' style='padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:14px;' autocomplete='current-password'>
          <button id='login-submit' class='btn btn-primary' style='margin-top:6px;'>Login</button>
          <div id='login-error' style='font-size:12px; color:#ef4444; min-height:16px;'></div>
        </div>
      </div>
    </div>

    

    <div id='admin-overlay' style='position:absolute; top:40px; bottom:0; left:0; right:0; display:none; align-items:flex-start; justify-content:center; background:rgba(17,24,39,.75);'>
      <div style='margin-top:24px; background:#fff; border-radius:12px; box-shadow:0 10px 25px rgba(0,0,0,.15); max-width:720px; width:100%; padding:16px;'>
        <div style='display:flex; align-items:center; justify-content:space-between;'>
          <div id='admin-title' style='font-size:18px; font-weight:600; color:#111827;'>Admin</div>
          <button id='admin-close' class='btn'>Close</button>
        </div>
        <div style='display:grid; grid-template-columns: 1fr 1fr; gap:16px; margin-top:12px;'>
          <div style='border:1px solid #e5e7eb; border-radius:10px; padding:12px;'>
            <div id='admin-create-title' style='font-weight:600; margin-bottom:8px;'>Create user</div>
            <label id='admin-label-username' style='font-size:13px;'>Username</label>
            <input id='admin-new-username' type='text' class='login-input' style='padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:14px;'>
            <label id='admin-label-password' style='font-size:13px; margin-top:8px;'>Password</label>
            <input id='admin-new-password' type='password' class='login-input' style='padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:14px;'>
            <label style='display:flex; align-items:center; gap:6px; font-size:13px; margin-top:8px;'>
              <input id='admin-new-isadmin' type='checkbox'> <span id='admin-label-admin'>Admin</span>
            </label>
            <button id='admin-create-btn' class='btn btn-primary' style='margin-top:10px;'>Create</button>
            <div id='admin-create-status' style='font-size:12px; color:#374151; min-height:16px; margin-top:6px;'></div>
          </div>
          <div style='border:1px solid #e5e7eb; border-radius:10px; padding:12px;'>
            <div id='admin-changes-title' style='font-weight:600; margin-bottom:8px;'>Recent changes</div>
            <div id='admin-changes' style='max-height:320px; overflow:auto; border:1px solid #f1f5f9; border-radius:8px;'></div>
          </div>
        </div>
        <div style='margin-top:16px; border:1px solid #e5e7eb; border-radius:10px; padding:12px;'>
          <div id='admin-lookup-title' style='font-weight:600; margin-bottom:8px;'>Zoek gebruiker</div>
          <div style='display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px;'>
            <input id='admin-lookup-name' type='text' class='login-input' style='padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; font-size:14px; min-width:200px;' placeholder='Zoek gebruiker…'>
            <button id='admin-lookup-btn' class='btn'>Zoek</button>
          </div>
          <div id='admin-lookup-results' style='max-height:320px; overflow:auto; border:1px solid #f1f5f9; border-radius:8px;'></div>
        </div>
        <div style='margin-top:16px; border:1px solid #e5e7eb; border-radius:10px; padding:12px;'>
          <div id='admin-export-title' style='font-weight:600; margin-bottom:8px;'>Export dataset</div>
          <div style='font-size:13px; color:#374151; margin-bottom:8px;'>Download the merged NL dataset without refetching OSM. For PBF, use the CLI below.</div>
          <div style='display:flex; gap:8px; align-items:center; flex-wrap:wrap;'>
            <button id='admin-export-geojson' class='btn btn-primary'>Download GeoJSON</button>
            <button id='admin-export-copy-cli' class='btn'>Copy PBF export CLI</button>
            <span id='admin-export-copy-status' style='font-size:12px; color:#374151;'></span>
          </div>
          <pre id='admin-export-cli' style='margin-top:8px; background:#f9fafb; color:#111827; padding:10px; border-radius:8px; border:1px solid #e5e7eb; font-size:12px; overflow:auto;'>wrangler r2 object get MAPDATA/nl.geojson --local --file nl.geojson
osmium convert nl.geojson -o updated.osm
osmium osm2pbf updated.osm -o updated.pbf
# Result: updated.pbf</pre>
        </div>
      </div>
    </div>
    <script>
      // Normalize `?locale=xx` to hash `#locale=xx` which iD expects
      (function normalizeLocaleParam() {
        try {
          const qs = new URLSearchParams(window.location.search);
          const qLocale = qs.get('locale');
          if (qLocale) {
            const hash = new URLSearchParams(window.location.hash.slice(1));
            if (!hash.get('locale')) {
              hash.set('locale', qLocale);
              window.location.hash = hash.toString();
            }
          } else {
            // Default to Dutch when no locale provided
            const hash = new URLSearchParams(window.location.hash.slice(1));
            if (!hash.get('locale')) {
              hash.set('locale', 'nl');
              window.location.hash = hash.toString();
            }
          }
        } catch (e) {
          // ignore
        }
      })();
    </script>

    <script>
      // Configure iD API base as requested
      window.ID = { apiUrl: '/api' };

      // When running the static editor on 8080, send API calls to the backend on 8788
      function apiOrigin() {
        try { return (window.location.port === '8080') ? 'http://localhost:8788' : ''; } catch (e) { return ''; }
      }
      function apiUrl(path) {
        try {
          if (!path) return path;
          if (path.startsWith('http://') || path.startsWith('https://')) return path;
          if (path.startsWith('/')) return apiOrigin() + path;
          return path;
        } catch (e) {
          return path;
        }
      }

      async function api(path, method = 'GET', body) {
        const url = apiUrl(path);
        const res = await fetch(url, { method, headers: body ? { 'Content-Type': 'application/json' } : undefined, body: body ? JSON.stringify(body) : undefined, credentials: 'include' });
        const ct = res.headers.get('content-type') || '';
        if (ct.includes('application/json')) return await res.json();
        return await res.text();
      }

      // Lightweight toast notifications
      function showToast(message, type = 'info') {
        try {
          const cont = document.getElementById('toast-container');
          if (!cont || !message) return;
          const el = document.createElement('div');
          el.textContent = message;
          el.style.pointerEvents = 'auto';
          el.style.padding = '8px 12px';
          el.style.borderRadius = '8px';
          el.style.boxShadow = '0 6px 16px rgba(0,0,0,.15)';
          el.style.fontSize = '13px';
          el.style.transition = 'opacity .3s ease';
          el.style.color = '#111827';
          el.style.opacity = '1';
          // Color by type
          if (type === 'success') {
            el.style.background = '#d1fae5';
            el.style.border = '1px solid #10b981';
          } else if (type === 'error') {
            el.style.background = '#fee2e2';
            el.style.border = '1px solid #ef4444';
          } else if (type === 'warning') {
            el.style.background = '#fef3c7';
            el.style.border = '1px solid #f59e0b';
          } else {
            el.style.background = '#e5e7eb';
            el.style.border = '1px solid #9ca3af';
          }
          cont.appendChild(el);
          setTimeout(() => { el.style.opacity = '0'; }, 2500);
          setTimeout(() => { try { cont.removeChild(el); } catch(e) {} }, 3200);
        } catch (e) {
          // ignore toast failures
        }
      }

      // Build a human-friendly error message from a Response + JSON body
      function buildErrorMessage(res, data, fallbackKey) {
        try {
          const status = (res && res.status) || 0;
          const base = (data && (data.error || data.message)) || (window.S ? S(fallbackKey) : 'Request failed');
          const hint = (data && data.hint) ? ` — ${data.hint}` : '';
          const suffix = status ? ` (${status})` : '';
          return `${base}${hint}${suffix}`;
        } catch (e) {
          return window.S ? S(fallbackKey) : 'Request failed';
        }
      }

      // --- Custom GeoJSON import/export helpers for iD ---
      // We persist a custom dataset in R2 and load it into iD’s base graph.
      // Entities we import are tagged with `dataset=scooternav`.
      const DATASET_TAG = 'scooternav';

      function exportGeoJSONFromContext(context) {
        const graph = context.graph();
        const diff = context.history().difference();
        const changed = diff.modified().concat(diff.created());
        const features = [];
        for (const entity of changed) {
          if (!entity) continue;
          // Only export changed ways to avoid persisting POIs/points
          if (entity.type !== 'way') continue;
          let geometry = null;
          try {
            if (entity.type === 'node') geometry = entity.asGeoJSON();
            else geometry = entity.asGeoJSON(graph);
          } catch (e) {
            // skip if geometry fails
            continue;
          }
          features.push({
            type: 'Feature',
            id: entity.id,
            properties: Object.assign({}, entity.tags),
            geometry
          });
        }
        return { type: 'FeatureCollection', features };
      }

      function importGeoJSONToBase(context, geojson) {
        if (!geojson || geojson.type !== 'FeatureCollection') return;
        const entities = [];
        const existingGraph = context && context.graph ? context.graph() : null;
        // Deduplicate nodes across imported features using a spatial hash
        const nodeCache = new Map(); // key: "lon,lat" rounded; value: iD.osmNode
        function coordKey(c) {
          try {
            const lon = +c[0];
            const lat = +c[1];
            // round to ~1cm precision to snap tiny offsets
            return `${lon.toFixed(7)},${lat.toFixed(7)}`;
          } catch (e) {
            return `${c}`;
          }
        }
        // Helper to create a node entity from [lon,lat]
        function createNode(coords, tags, id) {
          const key = coordKey(coords);
          const cached = nodeCache.get(key);
          if (cached) return cached;
          const nodeInit = { loc: coords, tags };
          if (id) nodeInit.id = id;
          const node = iD.osmNode().initialize([nodeInit]);
          nodeCache.set(key, node);
          return node;
        }
        // Helper to create a way from coordinates
        function createWayFromLineString(coords, tags, wayId) {
          const nodeIDs = [];
          const localNodes = [];
          for (let i = 0; i < coords.length; i++) {
            const c = coords[i];
            const n = createNode(c, {}, undefined);
            localNodes.push(n);
            nodeIDs.push(n.id);
          }
          // If a way with same id exists in the graph, preserve its tags (local edits win)
          let mergedTags = tags || {};
          try {
            if (existingGraph && wayId) {
              const existing = existingGraph.entity(wayId);
              if (existing && existing.tags) {
                mergedTags = Object.assign({}, tags || {}, existing.tags || {});
              }
            }
          } catch (e) {}
          // Ensure tag values are strings
          try {
            for (const k in mergedTags) {
              if (Object.prototype.hasOwnProperty.call(mergedTags, k)) {
                const v = mergedTags[k];
                if (v === null || v === undefined) {
                  delete mergedTags[k];
                } else {
                  mergedTags[k] = String(v);
                }
              }
            }
          } catch (e) {}
          const wayInit = { nodes: nodeIDs, tags: mergedTags };
          if (wayId) wayInit.id = wayId;
          const way = iD.osmWay().initialize([wayInit]);
          return { nodes: localNodes, way };
        }
        // Helper to create polygon way(s)
        function createPolygonWaysFromCoords(rings, tags, wayId) {
          // Use only the outer ring for simplicity; set area=yes
          const outer = rings && rings[0] ? rings[0] : [];
          const polygonTags = Object.assign({ area: 'yes' }, tags);
          const { nodes, way } = createWayFromLineString(outer, polygonTags, wayId);
          return { nodes, way };
        }

        for (const f of geojson.features || []) {
          const props = Object.assign({}, f.properties || {}, { dataset: DATASET_TAG });
          // Coerce all props to strings
          try {
            for (const k in props) {
              if (Object.prototype.hasOwnProperty.call(props, k)) {
                const v = props[k];
                if (v === null || v === undefined) {
                  delete props[k];
                } else {
                  props[k] = String(v);
                }
              }
            }
          } catch (e) {}
          // Skip point-like features based on tags
          try {
            const objType = (props.objecttype || '').toLowerCase();
            const highwayTag = (props.highway || '').toLowerCase();
            const dropPointHighways = new Set(['street_lamp','street_light','traffic_signals']);
            if (objType === 'point' || dropPointHighways.has(highwayTag)) {
              continue;
            }
          } catch (e) {}
          const g = f.geometry || {};
          const fid = f.id; // preserve iD entity id when available
          if (!g || !g.type) continue;
          try {
            if (g.type === 'Point' && Array.isArray(g.coordinates)) {
              // Skip importing point features to reduce visual noise (e.g., streetlights)
              continue;
            } else if (g.type === 'MultiPoint' && Array.isArray(g.coordinates)) {
              // Skip MultiPoint features entirely
              continue;
            } else if (g.type === 'LineString' && Array.isArray(g.coordinates)) {
              const { nodes, way } = createWayFromLineString(g.coordinates, props, fid);
              entities.push(...nodes);
              entities.push(way);
            } else if (g.type === 'MultiLineString' && Array.isArray(g.coordinates)) {
              // Create a separate way for each LineString
              for (const line of g.coordinates) {
                if (!Array.isArray(line)) continue;
                const { nodes, way } = createWayFromLineString(line, props, undefined);
                entities.push(...nodes);
                entities.push(way);
              }
            } else if (g.type === 'Polygon' && Array.isArray(g.coordinates)) {
              const { nodes, way } = createPolygonWaysFromCoords(g.coordinates, props, fid);
              entities.push(...nodes);
              entities.push(way);
            } else if (g.type === 'MultiPolygon' && Array.isArray(g.coordinates)) {
              // Create ways for each polygon; combine into a relation type=multipolygon
              const memberWays = [];
              const memberNodes = [];
              for (const poly of g.coordinates) {
                const { nodes, way } = createPolygonWaysFromCoords(poly, props, undefined);
                memberNodes.push(...nodes);
                memberWays.push(way);
              }
              entities.push(...memberNodes);
              entities.push(...memberWays);
              const members = memberWays.map(w => ({ id: w.id, type: 'way', role: 'outer' }));
              const relInit = { tags: Object.assign({ type: 'multipolygon' }, props), members };
              if (fid) relInit.id = fid;
              const rel = iD.osmRelation().initialize([relInit]);
              entities.push(rel);
            }
          } catch (e) {
            console.warn('Import feature failed', e);
          }
        }

        if (entities.length) {
          try {
            context.history().merge(entities);
          } catch (e) {
            console.error('Merge imported entities failed', e);
          }
        }
      }

      // Initial status will be updated after iD initializes

      function escapeHTML(input) {
        const s = String(input == null ? '' : input);
        return s
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function setLoginError(msg) {
        const el = document.getElementById('login-error');
        if (!el) return;
        const text = msg || '';
        el.textContent = text;
        if (text) {
          el.style.display = 'block';
          el.style.background = '#fee2e2';
          el.style.border = '1px solid #ef4444';
          el.style.padding = '6px 8px';
          el.style.borderRadius = '8px';
        } else {
          el.style.display = 'none';
        }
      }

      async function performLogin(username, password) {
        setLoginError('');
        const btn = document.getElementById('login-submit');
        const originalText = btn && btn.textContent;
        if (btn) { btn.disabled = true; btn.textContent = (window.S ? `${S('sign_in')}…` : 'Logging in…'); }
        try {
          const res = await fetch(apiUrl('/login'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password }),
            credentials: 'include'
          });
          let data = null;
          try { data = await res.json(); } catch(e) { /* non-JSON response */ }
          if (res.ok && data && data.ok) {
            // Succes: geen toast, UI wordt geüpdatet via refreshMe
            if (window._refreshMe) window._refreshMe();
          } else {
            let msg;
            if (data && (data.error || data.hint)) {
              msg = buildErrorMessage(res, data, 'login_failed');
            } else if (res.status === 429) {
              msg = (window.S ? S('login_rate_limited') : 'Too many attempts, try again later') + ' (429)';
            } else if (res.status >= 500) {
              msg = (window.S ? S('login_server_error') : 'Server error') + ` (${res.status})`;
            } else if (res.status === 403) {
              msg = (window.S ? S('forbidden') : 'Forbidden') + ' (403)';
            } else if (!data) {
              msg = window.S ? S('unexpected_response') : 'Unexpected server response';
            } else {
              msg = (window.S ? S('login_failed') : 'Login failed') + (res.status ? ` (${res.status})` : '');
            }
            setLoginError(msg);
          }
        } catch (e) {
          const msg = window.S ? S('network_error') : 'Network error';
          setLoginError(msg);
        } finally {
          if (btn) { btn.disabled = false; btn.textContent = originalText; }
        }
      }

      document.getElementById('btn-login').onclick = () => {
        const overlay = document.getElementById('map-overlay');
        if (overlay) overlay.style.display = 'flex';
        const u = document.getElementById('login-username');
        if (u) u.focus();
      };
          document.getElementById('btn-logout').onclick = async () => {
            try {
              await api('/logout', 'POST');
              showToast(S('logout_success'), 'info');
            } catch (e) {
              showToast(S('network_error'), 'error');
            } finally {
              if (window._refreshMe) window._refreshMe();
            }
          };

      // Admin UI handlers
      (function attachAdminHandlers() {
        const openBtn = document.getElementById('btn-admin');
        const overlay = document.getElementById('admin-overlay');
        const closeBtn = document.getElementById('admin-close');
        const createBtn = document.getElementById('admin-create-btn');
        const inputUser = document.getElementById('admin-new-username');
        const inputPass = document.getElementById('admin-new-password');
        const inputIsAdmin = document.getElementById('admin-new-isadmin');
        const statusEl = document.getElementById('admin-create-status');
        const exportGeoJSONBtn = document.getElementById('admin-export-geojson');
        const exportCopyCliBtn = document.getElementById('admin-export-copy-cli');
        const exportCopyStatus = document.getElementById('admin-export-copy-status');
        const exportCliEl = document.getElementById('admin-export-cli');

        async function loadAdminChanges() {
          const changesEl = document.getElementById('admin-changes');
          if (!changesEl) return;
          changesEl.innerHTML = '';
          try {
            const res = await fetch(apiUrl('/api/changes'));
            const json = await res.json();
            const entries = (json && json.entries) || [];
            if (entries.length === 0) {
              changesEl.innerHTML = `<div style='padding:8px; color:#6b7280;'>${S('admin_no_changes')}</div>`;
              return;
            }
            for (const e of entries) {
              const row = document.createElement('div');
              row.style.padding = '8px 10px';
              row.style.borderBottom = '1px solid #f3f4f6';
              const sum = escapeHTML(e.summary || 'Change');
              const user = escapeHTML(e.user || '');
              const ts = escapeHTML(e.timestamp || '');
              row.innerHTML = `<div style='font-size:13px; color:#111827;'>${sum}</div>
                <div style='font-size:12px; color:#6b7280;'>${user} — ${ts}</div>`;
              changesEl.appendChild(row);
            }
          } catch (err) {
            changesEl.innerHTML = `<div style='padding:8px; color:#ef4444;'>${S('admin_changes_failed')}</div>`;
          }
        }
        window._loadAdminChanges = loadAdminChanges;

        if (openBtn) openBtn.addEventListener('click', () => {
          if (overlay) overlay.style.display = 'flex';
          loadAdminChanges();
        });
        if (closeBtn) closeBtn.addEventListener('click', () => {
          if (overlay) overlay.style.display = 'none';
        });
        if (createBtn) createBtn.addEventListener('click', async () => {
          const username = (inputUser && inputUser.value) || '';
          const password = (inputPass && inputPass.value) || '';
          const isAdmin = !!(inputIsAdmin && inputIsAdmin.checked);
          statusEl.textContent = '';
          // Basic input validation
          if (!username.trim() || !password.trim()) {
            statusEl.style.color = '#ef4444';
            const msg = 'Vul gebruikersnaam en wachtwoord in';
            statusEl.textContent = msg;
            showToast(msg, 'warning');
            return;
          }
          // Disable while creating
          const originalText = createBtn.textContent;
          createBtn.disabled = true;
          createBtn.textContent = (window.S ? `${S('admin_create')}…` : 'Creating…');
          try {
            const res = await fetch(apiUrl('/admin/create-user'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({ username, password, isAdmin })
            });
            let j;
            try { j = await res.json(); } catch(e) { j = null; }
            if (res.ok && j && j.ok) {
              statusEl.style.color = '#10b981';
              statusEl.textContent = S('admin_create_success');
              showToast(S('admin_create_success'), 'success');
              if (inputUser) inputUser.value = '';
              if (inputPass) inputPass.value = '';
              if (inputIsAdmin) inputIsAdmin.checked = false;
              loadAdminChanges();
            } else {
              statusEl.style.color = '#ef4444';
              const errMsg = (j && j.error) ? j.error : (res.status === 403 ? 'Geen rechten (403)' : S('admin_create_error'));
              statusEl.textContent = errMsg;
              showToast(errMsg, 'error');
            }
          } catch (err) {
            statusEl.style.color = '#ef4444';
            const errMsg = S('admin_create_error');
            statusEl.textContent = errMsg;
            showToast(errMsg, 'error');
          } finally {
            // Restore button state
            createBtn.disabled = false;
            createBtn.textContent = originalText;
          }
        });

        // Admin export handlers
        if (exportGeoJSONBtn) exportGeoJSONBtn.addEventListener('click', async () => {
          try {
            // open in new tab to trigger attachment download
            window.open(apiUrl('/admin/export'), '_blank');
          } catch (err) {
            console.warn('Admin export failed', err);
          }
        });
        if (exportCopyCliBtn) exportCopyCliBtn.addEventListener('click', async () => {
          try {
            const text = (exportCliEl && exportCliEl.textContent) || '';
            await navigator.clipboard.writeText(text);
            if (exportCopyStatus) {
              exportCopyStatus.style.color = '#10b981';
              exportCopyStatus.textContent = 'CLI copied';
              setTimeout(() => { exportCopyStatus.textContent = ''; }, 2000);
            }
          } catch (err) {
            if (exportCopyStatus) {
              exportCopyStatus.style.color = '#ef4444';
              exportCopyStatus.textContent = 'Copy failed';
              setTimeout(() => { exportCopyStatus.textContent = ''; }, 2000);
            }
          }
        });
      })();

      // Attach login form handlers
      (function attachLoginHandlers() {
        const btn = document.getElementById('login-submit');
        const u = document.getElementById('login-username');
        const p = document.getElementById('login-password');
        if (btn) btn.addEventListener('click', () => {
          const username = u && u.value || '';
          const password = p && p.value || '';
          performLogin(username, password);
        });
        function onKey(e) {
          if (e.key === 'Enter') {
            const username = u && u.value || '';
            const password = p && p.value || '';
            performLogin(username, password);
          }
        }
        if (u) u.addEventListener('keydown', onKey);
        if (p) p.addEventListener('keydown', onKey);
      })();

      var container = document.getElementById('id-container');
      var newScript = document.createElement('script');
      newScript.type = 'text/javascript';
      newScript.onload = checkScript;
      newScript.onerror = checkScript;
      newScript.src = 'iD.min.js';

      document.getElementsByTagName('head')[0].appendChild(newScript);


      function checkScript() {
        if (typeof iD === 'undefined' || !iD.utilDetect().support) {
          container.innerHTML = 'Sorry, your browser is not currently supported. Please use another <a href="https://github.com/openstreetmap/iD#basics">browser</a> or <a href="https://wiki.openstreetmap.org/wiki/Editors">editor</a> to contribute to the map.';
          container.style.padding = '20px';

        } else {
          // App-specific translations for header/UI (avoid missing-key warnings)
          const appStrings = {
            'en': {
              login: 'Login',
              logout: 'Logout',
              logout_success: 'Logged out',
              save: 'Save',
              save_no_changes: 'No changes to save',
              load_local: 'Load Local Streets',
              admin: 'Admin',
              admin_close: 'Close',
              admin_create_user: 'Create user',
              admin_recent_changes: 'Recent changes',
              admin_create: 'Create',
              admin_create_success: 'User created',
              admin_create_error: 'Create failed',
              admin_no_changes: 'No recent changes',
              admin_changes_failed: 'Failed to load changes',
              admin_export: 'Export dataset',
              admin_export_download: 'Download GeoJSON',
              admin_export_copy_cli: 'Copy PBF export CLI',
              export_failed: 'Failed to export GeoJSON',
              not_logged_in: 'Not logged in',
              logged_in_as: 'Logged in as {username}',
              saved_changes: 'Saved {count} changes',
              save_failed: 'Save failed',
              editor_not_ready: 'Editor not loaded',
              login_required: 'Login required to view the map',
              username_label: 'Username',
              password_label: 'Password',
              sign_in: 'Login',
              login_failed: 'Login failed',
              login_invalid: 'Invalid username or password',
              login_rate_limited: 'Too many attempts, try again later',
              login_server_error: 'Server error',
              network_error: 'Network error',
              unexpected_response: 'Unexpected server response',
              forbidden: 'Forbidden',
              zoom_in_to_load_local: 'Zoom in to load local streets (>=14).',
              load_local_failed: 'Failed to load local streets',
              loading: 'Loading…',
              lookup_search: 'Search',
              lookup_placeholder: 'Search user…',
              lookup_results: 'Search results',
              lookup_total: 'Total changes',
              lookup_no_results: 'No entries found',
              lookup_failed: 'Search failed',
              lookup_user_not_found: 'User not found'
            },
            'nl': {
              login: 'Inloggen',
              logout: 'Uitloggen',
              logout_success: 'Uitgelogd',
              save: 'Opslaan',
              save_no_changes: 'Geen wijzigingen om op te slaan',
              load_local: 'Lokale straten laden',
              admin: 'Beheer',
              admin_close: 'Sluiten',
              admin_create_user: 'Gebruiker aanmaken',
              admin_recent_changes: 'Recente wijzigingen',
              admin_create: 'Aanmaken',
              admin_create_success: 'Gebruiker aangemaakt',
              admin_create_error: 'Aanmaken mislukt',
              admin_no_changes: 'Geen recente wijzigingen',
              admin_changes_failed: 'Laden van wijzigingen mislukt',
              admin_export: 'Dataset exporteren',
              admin_export_download: 'Download GeoJSON',
              admin_export_copy_cli: 'Kopieer PBF export CLI',
              export_failed: 'Exporteren van GeoJSON mislukt',
              not_logged_in: 'Niet ingelogd',
              logged_in_as: 'Ingelogd als {username}',
              saved_changes: '{count} wijzigingen opgeslagen',
              save_failed: 'Opslaan mislukt',
              editor_not_ready: 'Editor nog niet geladen.',
              login_required: 'Inloggen vereist om de kaart te zien',
              username_label: 'Gebruikersnaam',
              password_label: 'Wachtwoord',
              sign_in: 'Inloggen',
              login_failed: 'Inloggen mislukt',
              login_invalid: 'Onjuiste gebruikersnaam of wachtwoord',
              login_rate_limited: 'Te veel pogingen, probeer later opnieuw',
              login_server_error: 'Serverfout',
              network_error: 'Netwerkfout',
              unexpected_response: 'Onverwachte serverrespons',
              forbidden: 'Geen rechten',
              zoom_in_to_load_local: 'Zoom verder in om lokale straten te laden (>=14).',
              load_local_failed: 'Laden van lokale straten mislukt',
              loading: 'Laden…',
              lookup_search: 'Zoek',
              lookup_placeholder: 'Zoek gebruiker…',
              lookup_results: 'Zoekresultaten',
              lookup_total: 'Totaal wijzigingen',
              lookup_no_results: 'Geen entries gevonden',
              lookup_failed: 'Zoeken mislukt',
              lookup_user_not_found: 'Gebruiker niet gevonden'
            },
            'nl-NL': {
              login: 'Inloggen',
              logout: 'Uitloggen',
              logout_success: 'Uitgelogd',
              save: 'Opslaan',
              save_no_changes: 'Geen wijzigingen om op te slaan',
              load_local: 'Lokale straten laden',
              admin: 'Beheer',
              admin_close: 'Sluiten',
              admin_create_user: 'Gebruiker aanmaken',
              admin_recent_changes: 'Recente wijzigingen',
              admin_create: 'Aanmaken',
              admin_create_success: 'Gebruiker aangemaakt',
              admin_create_error: 'Aanmaken mislukt',
              admin_no_changes: 'Geen recente wijzigingen',
              admin_changes_failed: 'Laden van wijzigingen mislukt',
              admin_export: 'Dataset exporteren',
              admin_export_download: 'Download GeoJSON',
              admin_export_copy_cli: 'Kopieer PBF export CLI',
              export_failed: 'Exporteren van GeoJSON mislukt',
              not_logged_in: 'Niet ingelogd',
              logged_in_as: 'Ingelogd als {username}',
              saved_changes: '{count} wijzigingen opgeslagen',
              save_failed: 'Opslaan mislukt',
              editor_not_ready: 'Editor nog niet geladen.',
              login_required: 'Inloggen vereist om de kaart te zien',
              username_label: 'Gebruikersnaam',
              password_label: 'Wachtwoord',
              sign_in: 'Inloggen',
              login_failed: 'Inloggen mislukt',
              login_invalid: 'Onjuiste gebruikersnaam of wachtwoord',
              login_rate_limited: 'Te veel pogingen, probeer later opnieuw',
              login_server_error: 'Serverfout',
              network_error: 'Netwerkfout',
              unexpected_response: 'Onverwachte serverrespons',
              forbidden: 'Geen rechten',
              zoom_in_to_load_local: 'Zoom verder in om lokale straten te laden (>=14).',
              load_local_failed: 'Laden van lokale straten mislukt',
              loading: 'Laden…',
              lookup_search: 'Zoek',
              lookup_placeholder: 'Zoek gebruiker…',
              lookup_results: 'Zoekresultaten',
              lookup_total: 'Totaal wijzigingen',
              lookup_no_results: 'Geen entries gevonden',
              lookup_failed: 'Zoeken mislukt',
              lookup_user_not_found: 'Gebruiker niet gevonden'
            },
            'nl-BE': {
              login: 'Aanmelden',
              logout: 'Afmelden',
              logout_success: 'Afgemeld',
              save: 'Opslaan',
              save_no_changes: 'Geen wijzigingen om op te slaan',
              load_local: 'Lokale straten laden',
              admin: 'Beheer',
              admin_close: 'Sluiten',
              admin_create_user: 'Gebruiker aanmaken',
              admin_recent_changes: 'Recente wijzigingen',
              admin_create: 'Aanmaken',
              admin_create_success: 'Gebruiker aangemaakt',
              admin_create_error: 'Aanmaken mislukt',
              admin_no_changes: 'Geen recente wijzigingen',
              admin_changes_failed: 'Laden van wijzigingen mislukt',
              admin_export: 'Dataset exporteren',
              admin_export_download: 'Download GeoJSON',
              admin_export_copy_cli: 'Kopieer PBF export CLI',
              export_failed: 'Exporteren van GeoJSON mislukt',
              not_logged_in: 'Niet aangemeld',
              logged_in_as: 'Aangemeld als {username}',
              saved_changes: '{count} wijzigingen opgeslagen',
              save_failed: 'Opslaan mislukt',
              editor_not_ready: 'Editor nog niet geladen.',
              login_required: 'Aanmelden vereist om de kaart te zien',
              username_label: 'Gebruikersnaam',
              password_label: 'Wachtwoord',
              sign_in: 'Aanmelden',
              login_failed: 'Aanmelden mislukt',
              login_invalid: 'Onjuiste gebruikersnaam of wachtwoord',
              login_rate_limited: 'Te veel pogingen, probeer later opnieuw',
              login_server_error: 'Serverfout',
              network_error: 'Netwerkfout',
              unexpected_response: 'Onverwachte serverrespons',
              forbidden: 'Geen rechten',
              zoom_in_to_load_local: 'Zoom verder in om lokale straten te laden (>=14).',
              load_local_failed: 'Laden van lokale straten mislukt',
              loading: 'Laden…',
              lookup_search: 'Zoek',
              lookup_placeholder: 'Zoek gebruiker…',
              lookup_results: 'Zoekresultaten',
              lookup_total: 'Totaal wijzigingen',
              lookup_no_results: 'Geen entries gevonden',
              lookup_failed: 'Zoeken mislukt',
              lookup_user_not_found: 'Gebruiker niet gevonden'
            }
          };
          function currentLocaleCode() {
            const h = new URLSearchParams(window.location.hash.slice(1));
            const code = h.get('locale') || (navigator.language || 'nl');
            if (appStrings[code]) return code;
            // normalize short code
            if (String(code).toLowerCase().startsWith('nl')) return 'nl';
            return 'nl';
          }
          function S(key, vars) {
            const dict = appStrings[currentLocaleCode()] || appStrings['en'];
            let str = (dict && dict[key]) || appStrings['en'][key] || key;
            if (vars) for (const k of Object.keys(vars)) str = str.replace(`{${k}}`, vars[k]);
            return str;
          }
          function applyTranslations() {
        const $login = document.getElementById('btn-login');
        const $logout = document.getElementById('btn-logout');
        const $save = document.getElementById('btn-save');
        const $loadLocal = document.getElementById('btn-load-local');
        const $admin = document.getElementById('btn-admin');
            const $adminLookupBtn = document.getElementById('admin-lookup-btn');
            const $adminLookupInput = document.getElementById('admin-lookup-name');
        if ($login) $login.textContent = S('login');
        if ($logout) $logout.textContent = S('logout');
        if ($admin) $admin.textContent = S('admin');
        if ($save) {
          const badge = $save.querySelector('.badge');
          $save.innerHTML = S('save') + ' ' + (badge ? badge.outerHTML : "<span class='badge'>0</span>");
        }
        if ($loadLocal) $loadLocal.textContent = S('load_local');
            if ($adminLookupBtn) $adminLookupBtn.textContent = S('lookup_search');
            if ($adminLookupInput) $adminLookupInput.placeholder = S('lookup_placeholder');
            // Lookup UI strings
            const adminLookupTitle = document.getElementById('admin-lookup-title');
            if (adminLookupTitle) adminLookupTitle.textContent = S('lookup_results');
            // Also ensure status baseline text
            const statusText = document.getElementById('status-text');
            if (statusText) statusText.textContent = S('not_logged_in');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayDesc = document.getElementById('overlay-desc');
            if (overlayTitle) overlayTitle.textContent = S('login_required');
            if (overlayDesc) overlayDesc.textContent = S('not_logged_in');
            const labelUser = document.getElementById('label-username');
            const labelPass = document.getElementById('label-password');
            const loginBtn = document.getElementById('login-submit');
            if (labelUser) labelUser.textContent = S('username_label');
            if (labelPass) labelPass.textContent = S('password_label');
            if (loginBtn) loginBtn.textContent = S('sign_in');

            // Admin overlay strings
            const adminTitle = document.getElementById('admin-title');
            const adminClose = document.getElementById('admin-close');
            const adminCreateTitle = document.getElementById('admin-create-title');
            const adminChangesTitle = document.getElementById('admin-changes-title');
            const adminCreateBtn = document.getElementById('admin-create-btn');
            const adminLabelAdmin = document.getElementById('admin-label-admin');
            const adminLabelUser = document.getElementById('admin-label-username');
            const adminLabelPass = document.getElementById('admin-label-password');
            const adminExportTitle = document.getElementById('admin-export-title');
            const adminExportGeoJSON = document.getElementById('admin-export-geojson');
            const adminExportCopyCli = document.getElementById('admin-export-copy-cli');
            if (adminTitle) adminTitle.textContent = S('admin');
            if (adminClose) adminClose.textContent = S('admin_close');
            if (adminCreateTitle) adminCreateTitle.textContent = S('admin_create_user');
            if (adminChangesTitle) adminChangesTitle.textContent = S('admin_recent_changes');
            if (adminCreateBtn) adminCreateBtn.textContent = S('admin_create');
            if (adminLabelAdmin) adminLabelAdmin.textContent = S('admin');
            if (adminLabelUser) adminLabelUser.textContent = S('username_label');
            if (adminLabelPass) adminLabelPass.textContent = S('password_label');
            if (adminExportTitle) adminExportTitle.textContent = S('admin_export');
            if (adminExportGeoJSON) adminExportGeoJSON.textContent = S('admin_export_download');
            if (adminExportCopyCli) adminExportCopyCli.textContent = S('admin_export_copy_cli');
          }
          applyTranslations();

          // Load merged baseline + saved changes from the server
          let _mapLoadedOnce = false;
          async function loadMergedMapData() {
            if (!window._idContext) return;
            try {
              const res = await fetch('/api/map', { credentials: 'include' });
              const json = await res.json();
              if (res.ok && json && json.type === 'FeatureCollection') {
                try { window._idContext.history().reset(); } catch (e) {}
                importGeoJSONToBase(window._idContext, json);
                try { zoomToGeoJSON(json); } catch (e) {}
                updateSaveButton();
                _mapLoadedOnce = true;
              } else {
                console.warn('Load merged map failed', json);
              }
            } catch (e) {
              console.warn('Load merged map error', e);
            }
          }

          // Auto-load merged map data after login
          async function autoLoadMap() {
            if (_mapLoadedOnce) return;
            await loadMergedMapData();
            try { zoomToNL(); } catch (e) {}
          }

          // Compute extent from GeoJSON and center/zoom map
          function zoomToGeoJSON(geojson) {
            if (!geojson || !Array.isArray(geojson.features) || geojson.features.length === 0) return;
            let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;
            for (const f of geojson.features) {
              const g = f.geometry;
              if (!g) continue;
              const collect = (coord) => {
                if (!Array.isArray(coord) || coord.length < 2) return;
                const lon = +coord[0];
                const lat = +coord[1];
                if (isNaN(lon) || isNaN(lat)) return;
                if (lon < minLon) minLon = lon;
                if (lat < minLat) minLat = lat;
                if (lon > maxLon) maxLon = lon;
                if (lat > maxLat) maxLat = lat;
              };
              if (g.type === 'Point') {
                collect(g.coordinates);
              } else if (g.type === 'LineString') {
                for (const c of g.coordinates) collect(c);
              } else if (g.type === 'Polygon') {
                for (const ring of g.coordinates) for (const c of ring) collect(c);
              } else if (g.type === 'MultiPolygon') {
                for (const poly of g.coordinates) for (const ring of poly) for (const c of ring) collect(c);
              }
            }
            if (!isFinite(minLon) || !isFinite(minLat) || !isFinite(maxLon) || !isFinite(maxLat)) return;
            const centerLon = (minLon + maxLon) / 2;
            const centerLat = (minLat + maxLat) / 2;
            const dx = Math.abs(maxLon - minLon);
            const dy = Math.abs(maxLat - minLat);
            let zoom = 17;
            const span = Math.max(dx, dy);
            if (span > 30) zoom = 2;
            else if (span > 10) zoom = 5;
            else if (span > 2) zoom = 10;
            else if (span > 0.2) zoom = 13;
            else if (span > 0.02) zoom = 16;
            try { window._idContext.map().centerZoom([centerLon, centerLat], zoom); } catch (e) {}
          }

          // Quick default view over the Netherlands (avoids heavy extent computation)
          function zoomToNL() {
            try { window._idContext.map().centerZoom([5.3, 52.1], 7); } catch (e) {}
          }

          document.getElementById('btn-save').onclick = async function () {
            // If not logged in or no context yet, do nothing
            if (!window._idContext) {
              showToast(S('login_required'), 'error');
              return;
            }
            // Require login for saving; prompt if not logged in
            try {
              const me = await api('/me');
              if (!me || !me.username) {
                const overlay = document.getElementById('map-overlay');
                if (overlay) overlay.style.display = 'flex';
                showToast(S('login_required'), 'error');
                return;
              }
            } catch (e) {
              const overlay = document.getElementById('map-overlay');
              if (overlay) overlay.style.display = 'flex';
              showToast(S('login_required'), 'error');
              return;
            }
            try {
              const diff = window._idContext.history().difference();
              const changeCount = diff.length();
              if (changeCount === 0) {
                showToast(S('save_no_changes') || 'Geen wijzigingen om op te slaan', 'warning');
                updateSaveButton();
                return;
              }
              const gj = exportGeoJSONFromContext(window._idContext);
              const res = await fetch(apiUrl('/api/save'), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(gj), credentials: 'include' });
              let j = null;
              try { j = await res.json(); } catch(e) {}
            if (res.ok) {
              showToast(S('saved_changes', { count: changeCount }), 'success');
              // Na opslaan: herlaad de samengevoegde dataset zodat wijzigingen zichtbaar blijven
              try {
                await loadMergedMapData();
              } catch (err) {
                console.warn('Post-save reload failed', err);
                updateSaveButton();
              }
              refreshMe();
              } else {
                const msg = buildErrorMessage(res, j, 'save_failed');
                showToast(msg, 'error');
              }
            } catch (e) {
              console.error(e);
              showToast(S('save_failed'), 'error');
            }
          };

          // --- Admin gebruikerszoekfunctie ---
          (function attachAdminLookup(){
            const input = document.getElementById('admin-lookup-name');
            const btn = document.getElementById('admin-lookup-btn');
            const results = document.getElementById('admin-lookup-results');

            async function runAdminLookup() {
              const name = (input && input.value || '').trim();
              if (!name) return;
              results.innerHTML = `<div style='padding:10px; color:#6b7280;'>${S('loading')}</div>`;
              const originalText = btn && btn.textContent;
              if (btn) { btn.disabled = true; btn.textContent = (window.S ? `${S('lookup_search')}…` : 'Search…'); }
              let me;
              try { me = await api('/me'); } catch(e) {}
              if (!me || !me.isAdmin) {
                results.innerHTML = `<div style='padding:10px; color:#ef4444;'>${S('login_required')}</div>`;
                showToast(S('login_required'), 'error');
                if (btn) { btn.disabled = false; btn.textContent = originalText; }
                return;
              }
              try {
                const res = await fetch(apiUrl(`/api/user?name=${encodeURIComponent(name)}&limit=50`), { credentials: 'include' });
                const ct = res.headers.get('content-type') || '';
                let j = null;
                let textMsg = '';
                if (ct.includes('application/json')) {
                  try { j = await res.json(); } catch(e) { j = null; }
                } else {
                  try { textMsg = await res.text(); } catch(e) { textMsg = ''; }
                }
                if (!res.ok) {
                  const payload = j || (textMsg ? { error: textMsg } : null);
                  const userMsg = escapeHTML((payload && payload.error) ? payload.error : S('lookup_failed'));
                  const hintMsg = escapeHTML((payload && payload.hint) ? payload.hint : '');
                  let msgHtml = `<div style='font-weight:600;'>${userMsg}</div>`;
                  if (hintMsg) msgHtml += `<div style='font-size:12px; color:#6b7280;'>${hintMsg}</div>`;
                  results.innerHTML = `<div style='padding:10px 12px; color:#ef4444;'>${msgHtml}</div>`;
                  // Log statuscode in console voor debugging, maar toon alleen duidelijke tekst in UI
                  try { console.warn('Lookup failed', res.status, payload); } catch(e) {}
                  showToast(userMsg, 'error');
                } else {
                  const entries = Array.isArray(j.entries) ? j.entries : [];
                  const total = (j.user && j.user.changeCount) || 0;
                  const uname = escapeHTML((j.user && j.user.username) || name);
                  let html = `
                <div style='padding:10px 12px; border-bottom:1px solid #f3f4f6;'>
                  <div style='font-weight:600; color:#111827;'>${uname}</div>
                  <div style='font-size:12px; color:#6b7280;'>${S('lookup_total')}: ${total}</div>
                </div>`;
              if (entries.length === 0) {
                html += `<div style='padding:10px 12px; color:#6b7280;'>${S('lookup_no_results')}</div>`;
              } else {
                html += `<div>`;
                for (const e of entries) {
                  const sum = escapeHTML(e.summary || 'Wijziging');
                  const ts = escapeHTML(e.timestamp || '');
                  html += `<div style='padding:8px 12px; border-bottom:1px solid #f3f4f6;'>
                    <div style='font-size:13px; color:#111827;'>${sum}</div>
                    <div style='font-size:12px; color:#6b7280;'>${ts}</div>
                  </div>`;
                }
                html += `</div>`;
              }
              results.innerHTML = html;
            }
          } catch (err) {
            let msg = S('lookup_failed');
            // Toon duidelijke tekst, zonder statuscode in de UI
            if (err && err.status) {
              if (err.status === 401) msg = S('login_required');
              else if (err.status === 403) msg = S('forbidden');
              else if (err.status === 404) msg = S('lookup_user_not_found');
            }
            results.innerHTML = `<div style='padding:10px 12px; color:#ef4444;'>${escapeHTML(msg)}</div>`;
            try { console.warn('Lookup error', err && err.status, err); } catch(e) {}
          } finally {
            if (btn) { btn.disabled = false; btn.textContent = originalText; }
          }
        }

            if (btn) btn.addEventListener('click', runAdminLookup);
            if (input) input.addEventListener('keydown', function(e){ if (e.key === 'Enter') runAdminLookup(); });
          })();

          // Update Save badge and enable state; guard for uninitialized context
          function updateSaveButton() {
            const $save = document.getElementById('btn-save');
            const badge = $save && $save.querySelector('.badge');
            if (!window._idContext) {
              if (badge) badge.textContent = 0;
              if ($save) $save.disabled = true;
              return;
            }
            const diff = window._idContext.history().difference();
            const count = diff.length();
            if (badge) badge.textContent = count;
            // Disable Save when there are no changes
            if ($save) $save.disabled = (count === 0);
          }

          // Determine current viewport bbox from iD map extent
          function computeViewportBBox() {
            try {
              const ext = window._idContext.map().extent();
              if (ext && typeof ext.polygon === 'function') {
                const poly = ext.polygon(); // array of [lon, lat]
                let minLon = Infinity, minLat = Infinity, maxLon = -Infinity, maxLat = -Infinity;
                for (const pt of poly) {
                  const lon = +pt[0];
                  const lat = +pt[1];
                  if (isNaN(lon) || isNaN(lat)) continue;
                  if (lon < minLon) minLon = lon;
                  if (lat < minLat) minLat = lat;
                  if (lon > maxLon) maxLon = lon;
                  if (lat > maxLat) maxLat = lat;
                }
                if (isFinite(minLat) && isFinite(minLon) && isFinite(maxLat) && isFinite(maxLon)) {
                  return [minLat, minLon, maxLat, maxLon];
                }
              }
            } catch (e) {}
            // Fallback to NL bbox
            return [50.7, 3.2, 53.7, 7.2];
          }

          // Load local streets (residential/service/secondary/tertiary) into the base graph
          document.getElementById('btn-load-local').onclick = async function () {
            if (!window._idContext) {
              showToast(S('editor_not_ready'), 'error');
              return;
            }
            // Require sufficient zoom level for local street import
            try {
              const z = window._idContext.map().zoom();
              if (z < 14) {
                showToast(S('zoom_in_to_load_local'), 'warning');
                return;
              }
            } catch (e) {}
            const bbox = computeViewportBBox();
            try {
              const url = `/api/import-bbox?bbox=${bbox.join(',')}&classes=motorway,trunk,primary,secondary,tertiary,residential,service,unclassified,road,cycleway,motorway_link,trunk_link,primary_link,secondary_link,tertiary_link`;
              const res = await fetch(apiUrl(url), { credentials: 'include' });
              let json = null;
              try { json = await res.json(); } catch(e) { json = null; }
              if (res.ok && json && json.ok && json.data && json.data.type === 'FeatureCollection') {
                importGeoJSONToBase(window._idContext, json.data);
                try { zoomToGeoJSON(json.data); } catch (e) {}
              } else {
                const msg = buildErrorMessage(res, json, 'load_local_failed');
                showToast(msg, 'error');
              }
            } catch (e) {
              console.error('Load local streets failed', e);
              showToast(S('load_local_failed'), 'error');
            }
          };

          // Boot iD only after login
          function bootID() {
            // Force default background to OpenStreetMap (MAPNIK) and persist prefs
            try {
              window.localStorage.setItem('background-last-used', 'MAPNIK');
              window.localStorage.setItem('background-last-used-toggle', 'MAPNIK');
              // Optional: set custom template for consistency if user later toggles to custom
              window.localStorage.setItem('background-custom-template', 'https://tile.openstreetmap.org/{zoom}/{x}/{y}.png');
            } catch (e) {}
            var context = iD.coreContext()
              .assetPath('')
              .locale(currentLocaleCode())
              .containerNode(container);
            context.init();
            // Ensure an immediate NL-centered view after init (helps Safari)
            try { context.map().centerZoom([5.3, 52.1], 7); } catch (e) {}
            window._idContext = context;
            // Force non-wireframe rendering (avoid black strokes at high zoom)
            try {
              context.map().areaFill('full'); // persist preference internally
              // Also ensure surface class reflects non-wireframe immediately
              var surface = context.surface && context.surface();
              if (surface) surface.classed('fill-wireframe', false);
            } catch (e) {}
            // Keep connection object but disable remote OSM fetching to avoid unintended loads
            try {
              const conn = context.connection();
              if (conn && conn.toggle) {
                conn.toggle(false);
                if (conn.reset) conn.reset();
              }
            } catch (e) {
              // ignore
            }
            // Set a safe background; prefer OpenStreetMap (MAPNIK), else fall back to 'custom' OSM tiles or 'none'
            try {
              const mapnik = context.background().findSource('MAPNIK');
              if (mapnik) {
                context.background().baseLayerSource(mapnik);
              } else {
                const custom = context.background().findSource('custom');
                if (custom && custom.template) {
                  custom.template('https://tile.openstreetmap.org/{zoom}/{x}/{y}.png');
                  context.background().baseLayerSource(custom);
                } else {
                  const none = context.background().findSource('none');
                  if (none) context.background().baseLayerSource(none);
                }
              }
            } catch (e) {
              // ignore
            }
            // Block Cmd/Ctrl+S to prevent entering iD Save mode
            window.addEventListener('keydown', function(e) {
              const isSaveShortcut = (e.key && e.key.toLowerCase() === 's') && (e.metaKey || e.ctrlKey);
              if (isSaveShortcut) {
                e.preventDefault();
                e.stopPropagation();
              }
            }, true);
            // QoL: Sluit overlays met Escape
            window.addEventListener('keydown', function(e) {
              if (e.key === 'Escape') {
                const overlay = document.getElementById('map-overlay');
                if (overlay) overlay.style.display = 'none';
                const adminOverlay = document.getElementById('admin-overlay');
                if (adminOverlay) adminOverlay.style.display = 'none';
              }
            }, true);
            // disable boundaries (unless we have an explicit disable_features list)
            var q = iD.utilStringQs(window.location.hash);
            // Default to showing only roads; hide points and non-road features.
            // Even if a disable_features param exists, force-hide point layers.
            var feat = context.features();
            // Show cycleways/paths by keeping 'paths' enabled. We still hide
            // non-road/non-cycle layers to reduce visual clutter.
            var toDisable = ['boundaries', 'address_points', 'points', 'buildings', 'building_parts', 'indoor', 'landuse', 'water', 'rail', 'pistes', 'aerialways', 'power', 'past_future', 'others'];
            toDisable.forEach(function(k){
              try { feat.disable(k); } catch(e) { /* ignore unknown keys */ }
            });
            context.history().on('change.topbar', updateSaveButton);
            updateSaveButton();

            // Auto-load roads when sufficiently zoomed in (throttled during move)
            let _autoLocalFetching = false;
            let _autoLastLoadTime = 0;
            try {
              context.map().on('move.autoLocal', async function () {
                if (!window._idContext) return;
                const z = window._idContext.map().zoom();
                const now = Date.now();
                if (z >= 14 && !_autoLocalFetching && (now - _autoLastLoadTime > 2000)) {
                  _autoLocalFetching = true;
                  const bbox = computeViewportBBox();
                  try {
                    const url = `/api/import-bbox?bbox=${bbox.join(',')}&classes=motorway,trunk,primary,secondary,tertiary,residential,service,unclassified,road,cycleway,motorway_link,trunk_link,primary_link,secondary_link,tertiary_link`;
                    const res = await fetch(apiUrl(url), { credentials: 'include' });
                    const json = await res.json();
                    if (res.ok && json && json.ok && json.data && json.data.type === 'FeatureCollection') {
                      importGeoJSONToBase(window._idContext, json.data);
                    }
                  } catch (e) {
                    console.warn('Auto local streets load failed', e);
                  } finally {
                    _autoLocalFetching = false;
                    _autoLastLoadTime = Date.now();
                  }
                }
              });
            } catch (e) {}
          }

          // Refresh status, toggle map visibility, and boot on login
          async function refreshMe() {
            try {
              const me = await api('/me');
              const statusText = document.getElementById('status-text');
              const dot = document.getElementById('status-dot');
              const overlay = document.getElementById('map-overlay');
              const adminBtn = document.getElementById('btn-admin');
              const adminOverlay = document.getElementById('admin-overlay');
              const logoutBtn = document.getElementById('btn-logout');
              const loginBtn = document.getElementById('btn-login');
              const loadLocalBtn = document.getElementById('btn-load-local');
              if (me && me.username) {
                window._isLoggedIn = true;
                statusText.textContent = `${S('logged_in_as', { username: me.username })} (changes: ${me.changeCount || 0})`;
                dot.classList.add('online');
                // Show map, hide overlay
                container.style.display = 'block';
                if (overlay) overlay.style.display = 'none';
                if (adminBtn) adminBtn.style.display = me.isAdmin ? 'inline-block' : 'none';
                if (adminOverlay && !me.isAdmin) adminOverlay.style.display = 'none';
                if (loginBtn) loginBtn.style.display = 'none';
                if (logoutBtn) {
                  logoutBtn.style.display = 'inline-block';
                  logoutBtn.disabled = false;
                }
                if (loadLocalBtn) loadLocalBtn.disabled = false;
                if (!window._idContext) bootID();
                await autoLoadMap();
              } else {
                window._isLoggedIn = false;
                statusText.textContent = S('not_logged_in');
                dot.classList.remove('online');
                // Show map even when not logged in; hide admin UI
                container.style.display = 'block';
                if (overlay) overlay.style.display = 'none';
                if (adminBtn) adminBtn.style.display = 'none';
                if (adminOverlay) adminOverlay.style.display = 'none';
                if (loginBtn) loginBtn.style.display = 'inline-block';
                if (logoutBtn) {
                  // Verberg de uitlogknop wanneer niet ingelogd
                  logoutBtn.style.display = 'none';
                  logoutBtn.disabled = true;
                }
                if (loadLocalBtn) loadLocalBtn.disabled = true;
                if (!window._idContext) bootID();
                updateSaveButton();
              }
            } catch {
              window._isLoggedIn = false;
              const statusText = document.getElementById('status-text');
              const dot = document.getElementById('status-dot');
              const overlay = document.getElementById('map-overlay');
              const adminBtn = document.getElementById('btn-admin');
              const adminOverlay = document.getElementById('admin-overlay');
              const logoutBtn = document.getElementById('btn-logout');
              const loginBtn = document.getElementById('btn-login');
              const loadLocalBtn = document.getElementById('btn-load-local');
              statusText.textContent = S('not_logged_in');
              dot.classList.remove('online');
              // On error, still boot and show map to avoid indefinite loading
              container.style.display = 'block';
              if (overlay) overlay.style.display = 'none';
              if (adminBtn) adminBtn.style.display = 'none';
              if (adminOverlay) adminOverlay.style.display = 'none';
              if (loginBtn) loginBtn.style.display = 'inline-block';
              if (logoutBtn) {
                // Verberg de uitlogknop bij fout of niet ingelogd
                logoutBtn.style.display = 'none';
                logoutBtn.disabled = true;
              }
              if (loadLocalBtn) loadLocalBtn.disabled = true;
              if (!window._idContext) bootID();
              updateSaveButton();
            }
          }
          window._refreshMe = refreshMe;

      refreshMe();
        }
      }
    </script>
  </body>
</html>
